private static void runAlgorithm(List<String> currentLines, Stack<String> currentRunningStack, Map<String, Object> currentVariableMap) {

    while (!currentRunningStack.empty()){  // The loop continues while there are items in the stack
        String currentLine = currentRunningStack.getLast();  // Get the topmost line

        switch (Statement.getStatement(currentLine)) {  // Determine the type of statement

            case ASSIGNMENT:
                parseKeyValuePair(currentRunningStack.pop(), currentVariableMap);  // Handle assignment
                break;

            case IF:
    // Get the index of the `if` line
    int indexIf = currentLines.indexOf(currentRunningStack.peek());
    currentRunningStack.pop(); // Remove the `if` line from the stack

    // Extract the condition from the `if` statement
    Matcher ifMatcher = Statement.IF.getPattern().matcher(currentLines.get(indexIf).strip());
    if (ifMatcher.find()) {
        String condition = ifMatcher.group(0).substring(3).strip(); // Get the condition after "if"

        // Evaluate the condition
        boolean conditionMet = createWhileLoop.condition_is_met(condition, currentVariableMap);

        if (conditionMet) {
            // Execute the `if` block
            List<String> ifBlock = extractBlock(currentLines, indexIf);
            runAlgorithm(ifBlock, currentRunningStack, currentVariableMap);
        } else {
            // Skip the `if` block and look for `else`
            int elseIndex = findElseIndex(currentLines, indexIf);
            if (elseIndex != -1) {
                List<String> elseBlock = extractBlock(currentLines, elseIndex);
                runAlgorithm(elseBlock, currentRunningStack, currentVariableMap);
            }
        }
    }
    break;

case ELSE:
    // Do nothing as `else` is handled by the `if` case
    currentRunningStack.pop();
    break;


            case PRINT:
                int indexPrint = currentLines.indexOf(currentRunningStack.getLast());
                runPrint(indexPrint, currentLines, currentVariableMap);
                currentRunningStack.pop();
                break;

            case END:
                currentRunningStack.pop();  // Remove 'end' marking the end of a block
                break;

            default:
                currentRunningStack.pop();  // If no case matches, just pop the line from the stack
                break;
        }
    }
}

private static List<String> extractBlock(List<String> lines, int startIndex) {
    List<String> block = new ArrayList<>();
    int indentationLevel = 0;

    for (int i = startIndex + 1; i < lines.size(); i++) {
        String line = lines.get(i).strip();

        if (line.equals("end") && indentationLevel == 0) {
            break; // End of block
        } else if (line.equals("if") || line.equals("else")) {
            indentationLevel++;
        } else if (line.equals("end")) {
            indentationLevel--;
        }

        block.add(line);
    }
    return block;
}
private static int findElseIndex(List<String> lines, int ifIndex) {
    for (int i = ifIndex + 1; i < lines.size(); i++) {
        String line = lines.get(i).strip();
        if (line.equals("else")) {
            return i;
        } else if (line.equals("end")) {
            break;
        }
    }
    return -1; // No `else` found
}

